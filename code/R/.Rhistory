library("readxl")     # for reading excel files
library("png")        # for adding images to ggplot
library("egg")        # for geom_custom()
library("grid")       # functions for dealing with images
library("ggpubr")     # for plotting
library("knitr")      # for knitting
library("janitor")    # for cleaning column names
library("transport")  # for computing Wasserstein distance
library("kableExtra") # for knitr tables
library("xtable")     # for latex tables
library("patchwork")  # for figure panels
library("corrr")      # for correlations
library("brms")       # for Bayesian data analysis
library("tidyverse")  # for wrangling and plotting
library("readxl")     # for reading excel files
library("png")        # for adding images to ggplot
library("egg")        # for geom_custom()
library("grid")       # functions for dealing with images
library("ggpubr")     # for plotting
library("knitr")      # for knitting
library("janitor")    # for cleaning column names
library("transport")  # for computing Wasserstein distance
library("kableExtra") # for knitr tables
library("xtable")     # for latex tables
library("patchwork")  # for figure panels
library("corrr")      # for correlations
library("brms")       # for Bayesian data analysis
library("tidyverse")  # for wrangling and plotting
theme_set(theme_classic() +
theme(text = element_text(size = 24)))
opts_chunk$set(comment = "",
fig.show = "hold")
options(dplyr.summarise.inform = F)
# function for printing out html or latex tables
print_table = function(data, format = "html", digits = 2){
if(format == "html"){
data %>%
kable(digits = digits) %>%
kable_styling()
}else if(format == "latex"){
data %>%
xtable(digits = digits) %>%
print(include.rownames = F,
booktabs = T)
}
}
# trial information from the adult plinko eye-tracking experiment
load("data/selection.RData")
# posterior distributions for the different models
load("data/posterior.RData")
# load data from adult participants
load("data/judgments.RData")
# raw data
df.data = read_excel(path = "../../data/plinko_online_experiment.xlsx",
sheet = "sheet1") %>%
clean_names() %>%
filter(exclude == "no") %>%
mutate(participant = 1:n()) %>%
relocate(participant)
# demographics
df.demographics = df.data %>%
select(participant, child_id, age, gender, race, condition,
sound_familiarization, practice_drops)
# participants' choices
df.choices = df.data %>%
select(participant, age, condition, contains("resp")) %>%
pivot_longer(cols = starts_with("resp"),
names_to = "trial",
values_to = "answer") %>%
mutate(answer = case_when(answer == "green" ~ "3",
answer == "yellow" ~ "2",
answer == "blue" ~ "1")) %>%
mutate(trial = as.numeric(str_remove(trial, "resp_trial"))) %>%
left_join(read_csv("../../data/plinko_online_experiment_counterbalance.csv",
show_col_types = FALSE),
by = c("condition", "trial")) %>%
mutate(across(c("condition", "answer", "world"),
~ as.numeric(.)))
df.choices = df.choices %>%
left_join(df.judgments %>%
rename(world = trial,
ground_truth = hole) %>%
filter(world %in% df.choices$world) %>%
distinct(world, ground_truth),
by = "world") %>%
mutate(correct = ifelse(answer == ground_truth, 1, 0)) %>%
na.omit()
# x positions of the holes
hole_positions = c(151.229172, 300, 448.770844)
df.model = df.choices %>%
distinct(world) %>%
left_join(df.selection %>%
select(world, hole, x),
by = "world") %>%
left_join(df.posterior %>%
select(world, hole, contains("_loss"), contains("entropy")),
by = c("world", "hole")) %>%
rename_with(.fn = ~ str_remove(., "loss_")) %>%
rename_with(.fn = ~ str_replace(., "combined", "both")) %>%
mutate(across(contains("hole"), .fns = ~ . * 100),
world_order = rank(entropy_both,
ties.method = "first")) %>%
select(world, world_order, contains("hole"),
entropy_vision, entropy_sound, entropy_both, -hole) %>%
arrange(world_order)
# fit parameter for matching model
fun_fit_matching_sd = function(sd_matching){
df.choices %>%
left_join(df.selection %>%
select(world, x),
by = "world") %>%
mutate(matching = dnorm(x - hole_positions,
sd = sd_matching,
log = T)) %>%
summarize(likelihood = -sum(matching)) %>%
pull(likelihood)
}
sd_optimal = optim(par = 1,
fn = fun_fit_matching_sd)
df.predictions = df.model %>%
pivot_longer(cols = contains("hole"),
names_to = c("answer", "model"),
names_sep = "_",
values_to = "prediction") %>%
mutate(answer = str_remove(answer, "hole"),
answer = factor(answer, levels = 1:3),
prediction = prediction / 100) %>%
pivot_wider(names_from = model,
values_from = prediction) %>%
mutate(baseline = 1/3) %>%
left_join(df.selection %>%
select(world, x),
by = "world") %>%
group_by(world) %>%
mutate(matching = dnorm(x - hole_positions, sd = sd_optimal$par),
matching = matching / sum(matching)) %>%
select(-x)
# add adult means to model predictions
df.adults = df.choices %>%
distinct(world) %>%
left_join(df.judgments %>%
rename(world = trial) %>%
select(experiment,
world,
participant,
answer = response,
ground_truth = hole),
by = "world")
df.predictions = df.predictions %>%
left_join(df.adults %>%
mutate(answer = factor(answer, levels = 1:3)) %>%
count(experiment, world, answer,
.drop = F) %>%
group_by(experiment, world) %>%
mutate(p = n / sum(n),
experiment = str_c("adult_", experiment)) %>%
ungroup() %>%
select(-n) %>%
pivot_wider(names_from = experiment,
values_from = p),
by = c("world", "answer")) %>%
ungroup()
# adult data
# model_selection = c("adult_vision", "adult_vision_sound", "baseline", "matching")
# computational models
model_selection = c("vision", "both", "baseline", "matching")
df.fits = df.choices %>%
mutate(answer = factor(answer, levels = 1:3)) %>%
left_join(df.predictions %>%
select(world, answer, all_of(model_selection)),
by = c("world", "answer")) %>%
mutate(across(all_of(model_selection), ~ ifelse(. == 0, 0.01, .))) %>%
group_by(age, participant) %>%
summarize(across(all_of(model_selection), ~ exp(sum(log(.))))) %>%
ungroup() %>%
rowwise() %>%
mutate(sum = sum(c_across(all_of(model_selection))),
across(all_of(model_selection), ~ . / sum)) %>%
select(-sum)
# model_selection = c("adult_vision", "adult_vision_sound", "baseline", "matching")
# computational models
model_selection = c("vision", "both", "baseline", "matching")
df.fits.adults = df.adults %>%
mutate(answer = as.factor(answer)) %>%
filter(world %in% unique(df.choices$world)) %>%
left_join(df.predictions %>%
select(world, answer, all_of(model_selection)),
by = c("world", "answer")) %>%
mutate(across(all_of(model_selection), ~ ifelse(. == 0, 0.01, .))) %>%
group_by(experiment, participant) %>%
summarize(across(all_of(model_selection), ~ exp(sum(log(.))))) %>%
ungroup() %>%
rowwise() %>%
mutate(sum = sum(c_across(all_of(model_selection))),
across(all_of(model_selection), ~ . / sum)) %>%
select(-sum)
df.predictions %>%
select(matching, vision, both) %>%
# correlate(method = "spearman") %>%
correlate() %>%
shave() %>%
fashion()
df.choices %>%
mutate(age = as.character(age)) %>%
group_by(age) %>%
summarize(pct_correct = sum(correct)/n()) %>%
bind_rows(df.adults %>%
filter(experiment == "vision_sound") %>%
mutate(correct = answer == ground_truth) %>%
summarize(pct_correct = sum(correct)/n()) %>%
mutate(age = "adult",
.before = pct_correct)) %>%
print_table()
df.stat = df.choices %>%
select(participant, age, trial, answer) %>%
mutate(answer = as.factor(answer))
fit.age_answer = brm(formula = answer ~ 1 + age + (1 | participant),
data = df.stat,
family = categorical(),
seed = 1,
file = "cache/fit.age_answer")
df.stat = df.choices %>%
select(participant, age, trial, correct)
fit.age_correct = brm(formula = correct ~ 1 + age + (1 | participant),
data = df.stat,
family = "bernoulli",
seed = 1,
file = "cache/fit.age_correct")
ggplot(data = df.data %>%
mutate(age = as.factor(age)),
mapping = aes(x = age,
fill= age)) +
geom_bar(stat = "count",
color = "black") +
geom_text(mapping = aes(label = stat(count)),
stat = "count",
nudge_y = 0.5,
size = 5) +
labs(x = "years",
y = "number") +
scale_fill_brewer(palette = "Greens") +
theme(legend.position = "none")
ggsave(filename = "../../figures/plots/age_distribution.pdf",
width = 8,
height = 6)
ggplot(data = df.data,
mapping = aes(x = gender,
fill = gender)) +
geom_bar() +
geom_text(aes(label = stat(count)),
stat = 'count',
nudge_y = 0.5,
size = 5) +
labs(y = "Number") +
scale_fill_brewer(palette = "Set1") +
theme(legend.position = "none")
func_plot_with_images = function(data, model){
df.plot = data %>%
mutate(answer = factor(answer, levels = 1:3)) %>%
count(world, ground_truth, answer, .drop = F) %>%
group_by(world) %>%
mutate(p = n / sum(n)) %>%
mutate(correct = ground_truth == answer) %>%
ungroup()
df.plot.model = model %>%
select(world, answer, vision, both) %>%
pivot_longer(cols = c(vision, both),
names_to = "model",
values_to = "prediction") %>%
filter(model %in% c("vision", "both"))
func_load_image = function(world){
readPNG(str_c("../../stimuli/images/all_trials/png/trial_", world, ".png"))
}
# linking images and worlds
df.images = df.plot %>%
distinct(world) %>%
arrange(world) %>%
mutate(grob = map(.x = world,
.f = ~ func_load_image(world = .x)))
# plotting
p = ggplot(data = df.plot,
mapping = aes(x = answer,
y = p)) +
geom_col(mapping = aes(fill = answer,
size = correct),
alpha = 0.75,
color = "black",
show.legend = F) +
geom_point(data = df.plot.model,
mapping = aes(x = answer,
y = prediction,
shape = model,
group = model),
position = position_dodge(width = 0.5),
size = 3) +
geom_hline(yintercept = 1/3,
linetype = 2) +
geom_custom(data = df.images,
mapping = aes(data = grob,
x = -Inf,
y = Inf),
grob_fun = function(x) rasterGrob(x,
interpolate = T,
vjust = -0.05,
hjust = 0)) +
facet_wrap(~ world,
nrow = 1) +
labs(y = "proportion %") +
scale_size_manual(values = c(0.5, 1.5)) +
scale_y_continuous(breaks = seq(0, 1, 0.25),
labels = seq(0, 100, 25),
limits = c(0, 1),
expand = expansion(add = c(0, 0))) +
# scale_x_continuous(breaks = 1:3,
#                    labels = 1:3,
#                    limits = c(0, 4)) +
coord_cartesian(clip = "off") +
theme(panel.grid.major.y = element_line(),
axis.text.y = element_text(size = 25),
axis.text.x = element_text(size = 25),
axis.title = element_blank(),
strip.background = element_blank(),
strip.text = element_blank(),
panel.background = element_rect(fill = NA, color = "black"),
panel.spacing.x = unit(0.5, "cm"),
plot.margin = margin(t = 5, l = 1, r = 0.2, b = 0, unit = "cm"))
return(p)
}
models = c("baseline", "matching", "vision", "both")
models = c("baseline", "matching", "adult_vision", "adult_vision_sound")
df.plot = df.predictions %>%
select(world, answer, all_of(models)) %>%
pivot_longer(cols = -c(world, answer),
names_to = "model",
values_to = "prediction") %>%
filter(model %in% models) %>%
mutate(model = factor(model,
levels = models,
# labels = c("guessing", "matching", "vision", "vision & sound")))
labels = c("guessing", "matching",
"simulation (vision)","simulation (vision & sound)")))
func_load_image = function(world){
readPNG(str_c("../../figures/ground_truth/trial_", world, ".png"))
}
# linking images and worlds
df.images = df.plot %>%
distinct(world) %>%
arrange(world) %>%
mutate(grob = map(.x = world,
.f = ~ func_load_image(world = .x)))
df.text = df.plot %>%
distinct(world) %>%
arrange(world) %>%
mutate(index = 1:n(),
x = 0.8,
y = Inf)
# plotting
p = ggplot(data = df.plot,
mapping = aes(x = answer,
y = prediction)) +
geom_col(mapping = aes(fill = model,
group = model),
position = position_dodge(width = 0.9),
color = "black") +
geom_hline(yintercept = 1/3,
linetype = 2) +
geom_custom(data = df.images,
mapping = aes(data = grob,
x = -Inf,
y = Inf),
grob_fun = function(x) rasterGrob(x,
interpolate = T,
vjust = -0.05,
hjust = 0)) +
geom_text(data = df.text,
mapping = aes(x = x,
y = y,
label = index),
size = 12,
color = "white",
vjust = -4) +
facet_wrap(~ world,
nrow = 1) +
labs(y = "proportion %") +
scale_size_manual(values = c(0.5, 1.5)) +
scale_y_continuous(breaks = seq(0, 1, 0.25),
labels = str_c(seq(0, 100, 25), "%"),
limits = c(0, 1),
expand = expansion(add = c(0, 0))) +
coord_cartesian(clip = "off") +
scale_fill_brewer(palette = "Set1") +
theme(panel.grid.major.y = element_line(),
axis.text.y = element_text(size = 25),
axis.text.x = element_text(size = 25),
axis.title = element_blank(),
legend.position = "bottom",
strip.background = element_blank(),
strip.text = element_blank(),
panel.background = element_rect(fill = NA, color = "black"),
panel.spacing.x = unit(0.5, "cm"),
plot.margin = margin(t = 5, l = 1, r = 0.2, b = 0, unit = "cm"))
p
ggsave(filename = "../../figures/plots/model_predictions_adults.pdf",
# ggsave(filename = "../../figures/plots/model_predictions_models.pdf",
width = 22,
height = 5)
df.plot = df.predictions %>%
select(world, answer, baseline, matching, vision, both) %>%
pivot_longer(cols = c(baseline, matching, vision, both),
names_to = "model",
values_to = "prediction") %>%
filter(model %in% c("baseline", "matching", "vision", "both")) %>%
mutate(model = factor(model,
levels = c("baseline", "matching", "vision", "both"),
labels = c("baseline", "matching", "vision", "vision & sound")))
func_load_image = function(world){
readPNG(str_c("../../figures/ground_truth/trial_", world, ".png"))
}
# linking images and worlds
df.images = df.plot %>%
distinct(world) %>%
arrange(world) %>%
mutate(grob = map(.x = world,
.f = ~ func_load_image(world = .x)))
# plotting
p = ggplot(data = df.plot,
mapping = aes(x = answer,
y = prediction)) +
geom_col(mapping = aes(fill = model,
group = model),
position = position_dodge(width = 0.9),
color = "black") +
geom_hline(yintercept = 1/3,
linetype = 2) +
geom_custom(data = df.images,
mapping = aes(data = grob,
x = -Inf,
y = Inf),
grob_fun = function(x) rasterGrob(x,
interpolate = T,
vjust = -0.05,
hjust = 0)) +
facet_wrap(~ world,
nrow = 3) +
labs(y = "proportion %") +
scale_size_manual(values = c(0.5, 1.5)) +
scale_y_continuous(breaks = seq(0, 1, 0.25),
labels = str_c(seq(0, 100, 25), "%"),
limits = c(0, 1),
expand = expansion(add = c(0, 0))) +
coord_cartesian(clip = "off") +
scale_fill_brewer(palette = "Set1") +
theme(panel.grid.major.y = element_line(),
axis.text.y = element_text(size = 25),
axis.text.x = element_text(size = 25),
axis.title = element_blank(),
legend.position = "bottom",
strip.background = element_blank(),
strip.text = element_blank(),
panel.background = element_rect(fill = NA, color = "black"),
panel.spacing.x = unit(0.5, "cm"),
panel.spacing.y = unit(6.5, "cm"),
plot.margin = margin(t = 6.5, l = 1, r = 0.2, b = 0, unit = "cm"))
p
ggsave(filename = "../../figures/plots/model_predictions_3by3.pdf",
width = 10,
height = 18)
func_plot_with_images(data = df.choices,
model = df.predictions)
